security-scan:
  runs-on: ubuntu-latest
  steps:
    # Шаг 1: Получение кода
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Для полной истории коммитов

    # Шаг 2: Статический анализ кода (SAST)
    - name: Run Semgrep SAST
      uses: returntocorp/semgrep-action@v1
      with:
        config: "p/security-audit"  # Используем стандартные правила безопасности
        output-format: sarif        # Формат для интеграции с GitHub
        severity: ERROR            # Уровень важности проблем
      continue-on-error: true       # Не прерывать пайплайн для анализа результатов

    # Шаг 3: Загрузка результатов в GitHub Security
    - name: Upload SARIF results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: semgrep.sarif

    # Шаг 4: Анализ зависимостей
    - name: Run OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: "CMS"
        scan-dir: "."               # Директория для сканирования
        format: "ALL"               # Все форматы отчетов
        fail-on-cvss: 7             # Порог для fail
        suppression-file: ".github/dependency-check-suppression.xml" # Игнорируемые уязвимости

    # Шаг 5: Проверка на утечки секретов
    - name: Detect secrets with Gitleaks
      uses: zricethezav/gitleaks-action@v2
      with:
        config-path: ".github/gitleaks.toml" # Конфиг с исключениями
        redact: true                        # Скрывать чувствительные данные в логах

    # Шаг 6: Проверка IaC конфигураций
    - name: Check Infrastructure as Code
      uses: bridgecrewio/checkov-action@v12
      with:
        directory: ./
        skip_check: CKV_DOCKER_3,CKV_DOCKER_8 # Пропуск конкретных проверок
        soft_fail: true

build:
  needs: security-scan
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v3

    # Шаг 1: Логин в Docker Hub (для rate limits)
    - name: Login to Docker Hub
      if: github.ref == 'refs/heads/main'
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    # Шаг 2: Сборка Docker образа с метаданными
    - name: Build and tag Docker image
      run: |
        docker build \
          --tag $DOCKER_IMAGE:latest \
          --tag $DOCKER_IMAGE:${{ github.sha }} \
          --label "org.opencontainers.image.source=$GITHUB_SERVER_URL/$GITHUB_REPOSITORY" \
          --label "org.opencontainers.image.revision=$GITHUB_SHA" \
          --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
          .

    # Шаг 3: Сканирование образа на уязвимости
    - name: Scan image with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: $DOCKER_IMAGE:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH,MEDIUM'
        ignore-unfixed: true
        vuln-type: 'os,library'
        security-checks: 'vuln,config,secret'

    # Шаг 4: Загрузка результатов сканирования
    - name: Upload Trivy results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: trivy-results.sarif

    # Шаг 5: Генерация SBOM
    - name: Generate SBOM with Syft
      uses: anchore/sbom-action@v0
      with:
        image: $DOCKER_IMAGE:latest
        format: 'spdx-json'
        output: 'sbom.spdx.json'

    # Шаг 6: Проверка подписей образов (если используется cosign)
    - name: Verify image signatures
      if: env.ENABLE_SIGNATURE_VERIFICATION == 'true'
      run: |
        cosign verify \
          --key .github/cosign.pub \
          $DOCKER_IMAGE:latest

    # Шаг 7: Push образа в registry
    - name: Push Docker image
      if: github.ref == 'refs/heads/main'
      run: |
        docker push $DOCKER_IMAGE:latest
        docker push $DOCKER_IMAGE:${{ github.sha }}

deploy:
  needs: build
  if: github.ref == 'refs/heads/main'
  runs-on: ubuntu-latest
  environment: production  # Используем GitHub Environments для контроля доступа
  steps:
    - uses: actions/checkout@v3

    # Шаг 1: Установка SSH ключа
    - name: Install SSH key
      uses: shimataro/ssh-key-action@v2
      with:
        key: ${{ secrets.VPS_SSH_KEY }}
        known_hosts: ${{ secrets.KNOWN_HOSTS }}

    # Шаг 2: Развертывание с помощью Ansible (рекомендуемый способ)
    - name: Deploy with Ansible
      uses: arillso/ansible.action@v0.12.0
      with:
        playbook: .github/playbooks/deploy.yml
        inventory: ${{ secrets.VPS_HOST }},
        options: |
          --user=${{ secrets.VPS_USER }}
          --private-key=$HOME/.ssh/id_rsa
          --extra-vars "image=$DOCKER_IMAGE:${{ github.sha }}"

    # Альтернатива: Прямое развертывание через SSH
    - name: Direct deploy via SSH
      if: false  # Отключено в пользу Ansible
      uses: appleboy/ssh-action@master
      with:
        host: ${{ env.VPS_HOST }}
        username: ${{ env.VPS_USER }}
        key: ${{ env.VPS_SSH_KEY }}
        script: |
          # Обновляем сертификаты
          docker run --rm --name certbot \
            -v "/etc/letsencrypt:/etc/letsencrypt" \
            -v "/var/lib/letsencrypt:/var/lib/letsencrypt" \
            certbot/certbot renew

          # Останавливаем старый контейнер
          docker stop cms || true
          docker rm cms || true

          # Запускаем новый контейнер с безопасными настройками
          docker run -d \
            --name cms \
            --restart unless-stopped \
            --security-opt no-new-privileges \
            --read-only \
            -p 443:443 \
            -p 80:80 \
            -v /etc/letsencrypt:/etc/letsencrypt:ro \
            -v /var/run/mysqld/mysqld.sock:/var/run/mysqld/mysqld.sock \
            -e "ENV=production" \
            $DOCKER_IMAGE:${{ github.sha }}

    # Шаг 3: Запуск DAST тестов после деплоя
    - name: Run OWASP ZAP Baseline Scan
      uses: zaproxy/action-baseline@v0.7.0
      with:
        target: https://${{ env.VPS_HOST }}
        rules: .github/zap.conf
        fail_action: warn
